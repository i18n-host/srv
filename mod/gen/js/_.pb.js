// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: _.proto
/* eslint-disable */

import * as _P from "@3-/protoscript";

const EMPTY_BIN = new Uint8Array();

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

/**
 * Serializes T0 to protobuf.
 */
export const T0Encode = (msg) =>
  _P.getResultBuffer(T0Write(msg, _P.binaryWriter()));
/**
 * Deserializes T0 from protobuf.
 */
export const T0Decode = (bytes) => T0Read(T0New(), _P.binaryReader(bytes));
const T0New = () => [[], []];
const T0Write = _P.encoder(_P.writePackedUint32, _P.writeRepeatedBytes);
const T0Read = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        if (_P.isDelimited(reader)) {
          msg[0].push(..._P.readPackedUint32(reader));
        } else {
          msg[0].push(_P.readUint32(reader));
        }
        break;
      }
      case 2: {
        msg[1].push(_P.readBytes(reader));
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
/**
 * Serializes T1 to protobuf.
 */
export const T1Encode = (msg) =>
  _P.getResultBuffer(T1Write(msg, _P.binaryWriter()));
/**
 * Deserializes T1 from protobuf.
 */
export const T1Decode = (bytes) => T1Read(T1New(), _P.binaryReader(bytes));
const T1New = () => [EMPTY_BIN, EMPTY_BIN, EMPTY_BIN];
const T1Write = _P.encoder(_P.writeBytes, _P.writeBytes, _P.writeBytes);
const T1Read = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        msg[0] = _P.readBytes(reader);
        break;
      }
      case 2: {
        msg[1] = _P.readBytes(reader);
        break;
      }
      case 3: {
        msg[2] = _P.readBytes(reader);
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
/**
 * Serializes T2 to protobuf.
 */
export const T2Encode = (msg) =>
  _P.getResultBuffer(T2Write(msg, _P.binaryWriter()));
/**
 * Deserializes T2 from protobuf.
 */
export const T2Decode = (bytes) => T2Read(T2New(), _P.binaryReader(bytes));
const T2New = () => [];
const T2Write = _P.encoder1(_P.writePackedUint32);
const T2Read = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        if (_P.isDelimited(reader)) {
          msg.push(..._P.readPackedUint32(reader));
        } else {
          msg.push(_P.readUint32(reader));
        }
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
/**
 * Serializes T3 to protobuf.
 */
export const T3Encode = (msg) =>
  _P.getResultBuffer(T3Write(msg, _P.binaryWriter()));
/**
 * Deserializes T3 from protobuf.
 */
export const T3Decode = (bytes) => T3Read(T3New(), _P.binaryReader(bytes));
const T3New = () => [EMPTY_BIN, []];
const T3Write = _P.encoder(_P.writeBytes, _P.writePackedUint32);
const T3Read = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        msg[0] = _P.readBytes(reader);
        break;
      }
      case 2: {
        if (_P.isDelimited(reader)) {
          msg[1].push(..._P.readPackedUint32(reader));
        } else {
          msg[1].push(_P.readUint32(reader));
        }
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
/**
 * Serializes T4 to protobuf.
 */
export const T4Encode = (msg) =>
  _P.getResultBuffer(T4Write(msg, _P.binaryWriter()));
/**
 * Deserializes T4 from protobuf.
 */
export const T4Decode = (bytes) => T4Read(T4New(), _P.binaryReader(bytes));
const T4New = () => "";
const T4Write = _P.encoder1(_P.writeString);
const T4Read = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        msg = _P.readString(reader);
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
/**
 * Serializes T5 to protobuf.
 */
export const T5Encode = (msg) =>
  _P.getResultBuffer(T5Write(msg, _P.binaryWriter()));
/**
 * Deserializes T5 from protobuf.
 */
export const T5Decode = (bytes) => T5Read(T5New(), _P.binaryReader(bytes));
const T5New = () => ["", ""];
const T5Write = _P.encoder(_P.writeString, _P.writeString);
const T5Read = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        msg[0] = _P.readString(reader);
        break;
      }
      case 2: {
        msg[1] = _P.readString(reader);
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
/**
 * Serializes T6 to protobuf.
 */
export const T6Encode = (msg) =>
  _P.getResultBuffer(T6Write(msg, _P.binaryWriter()));
/**
 * Deserializes T6 from protobuf.
 */
export const T6Decode = (bytes) => T6Read(T6New(), _P.binaryReader(bytes));
const T6New = () => [0, 0, 0, 0, "", "", 0, ""];
const T6Write = _P.encoder(
  _P.writeSint32,
  _P.writeUint32,
  _P.writeUint32,
  _P.writeUint32,
  _P.writeString,
  _P.writeString,
  _P.writeUint32,
  _P.writeString,
);
const T6Read = (msg, reader) => {
  while (_P.nextField(reader)) {
    switch (_P.getFieldNumber(reader)) {
      case 1: {
        msg[0] = _P.readSint32(reader);
        break;
      }
      case 2: {
        msg[1] = _P.readUint32(reader);
        break;
      }
      case 3: {
        msg[2] = _P.readUint32(reader);
        break;
      }
      case 4: {
        msg[3] = _P.readUint32(reader);
        break;
      }
      case 5: {
        msg[4] = _P.readString(reader);
        break;
      }
      case 6: {
        msg[5] = _P.readString(reader);
        break;
      }
      case 7: {
        msg[6] = _P.readUint32(reader);
        break;
      }
      case 8: {
        msg[7] = _P.readString(reader);
        break;
      }
      default: {
        _P.skipField(reader);
        break;
      }
    }
  }
  return msg;
};
